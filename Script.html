<!-- Script.html -->

<script>

/**
 * Peer Review Frontend Logic
 *
 * Responsibilities:
 * - Bootstraps survey content, availability, and structure from the backend.
 * - Manages the multi-peer review workflow, including demographic data collection and submission.
 * - Enforces validation and visual feedback for errors and form state.
 *
 * Design Principles:
 * - Minimal global scope pollution via module pattern.
 * - Layered responsibilities: state handling, rendering, and server I/O are separated.
 * - Defensive programming: checks for failures, malformed data, and unavailable status.
 * - Responsive UI flow with clear affordances and feedback.
 */

const SurveyApp = (() => {
  // Constants
  const MAX_REVIEWS = 50;
  const STATUS_ACTIVE = 'ACTIVE';
  const STATUS_INACTIVE = 'INACTIVE';

  // Internal state
  let surveyStatus = null;
  let questions = [];
  let labelOptions = [];
  let reviewCount = 1;

  // Responses accumulate per peer review.
  const responses = [];

  // Demographic data containers
  let subjectDemographicQuestions = [];
  let subjectDemographicOptions = [];
  let peerDemographicQuestions = [];
  let peerDemographicOptions = [];

  const subjectDemographicData = [];
  const peerDemographicData = [];

  // DOM (Document Object Model) cache
  const dom = {
    formTitle: null,
    submissionMessage: null,
    loader: null,
    questionsContainer: null,
    submitBlock: null,
    reloadButton: null,
    submitButton: null,
    finalSubmitButton: null,
    demographicForm: null,
    demographicContainer: null,
    errorBanner: null, // optional element to show errors
  };



  // --- Initialization Functions ---
  /**
   * init()
   * 
   * Initializes the app after DOM is ready.
   * Caches DOM references, binds events, and loads initial content.
   */
  function init() {
    cacheDOM();
    wireEventHandlers();
    bootstrap();
  }


  /**
   * cacheDOM()
   * 
   * Caches all frequently used DOM elements for performance and convenience.
   *
   * Why:
   * Reduces repeated DOM queries during rendering and interactions.
   */
  function cacheDOM() {
    dom.formTitle = document.getElementById('formTitle');
    dom.submissionMessage = document.getElementById('submissionMessage');
    dom.loader = document.getElementById('loader');
    dom.questionsContainer = document.getElementById('questionsContainer');
    dom.submitBlock = document.getElementById('submitBlock');
    dom.reloadButton = document.getElementById('reloadButton');
    dom.submitButton = document.getElementById('submitButton');
    dom.finalSubmitButton = document.getElementById('finalSubmitButton');
    dom.demographicForm = document.getElementById('demographicForm');
    dom.demographicContainer = document.getElementById('demographicContainer');

    // Optionally create or reuse an error banner for user-visible errors.
    // If not present in HTML, create one dynamically.
    dom.errorBanner = document.getElementById('errorBanner');
    if (!dom.errorBanner) {
      dom.errorBanner = document.createElement('div');
      dom.errorBanner.id = 'errorBanner';
      dom.errorBanner.style.background = '#f8d7da';
      dom.errorBanner.style.color = '#721c24';
      dom.errorBanner.style.padding = '12px';
      dom.errorBanner.style.border = '2px solid #f5c6cb';
      dom.errorBanner.style.borderRadius = '4px';
      dom.errorBanner.style.margin = '8px 0';
      dom.errorBanner.style.display = 'none';
      // Insert before the form title for visibility.
      dom.formTitle?.parentElement?.insertBefore(dom.errorBanner, dom.formTitle.nextSibling);
    }
  }



  /**
   * wireEventHandlers()
   * 
   * Attaches click handlers to core buttons.
   *
   * Why:
   * Ensures interactions are centralized and debounced where needed.
   */
  function wireEventHandlers() {
    if (dom.reloadButton) {
      dom.reloadButton.addEventListener('click', () => {
        disableTemporarily(dom.reloadButton);
        sendResponse(false);
      });
    }

    if (dom.submitButton) {
      dom.submitButton.addEventListener('click', () => {
        disableTemporarily(dom.submitButton);
        sendResponse(true);
      });
    }

    if (dom.finalSubmitButton) {
      dom.finalSubmitButton.addEventListener('click', () => {
        disableTemporarily(dom.finalSubmitButton);
        sendSubmission();
      });
    }
  }



  /**
   * showError(message)
   * 
   * Displays a banner error to the user and logs it in console.
   *
   * Why:
   * Combines dev debugging and user-friendly error presentation.
   * 
   * @param {string} message - The message to display to the user.
   */
  function showError(message) {
    console.error('[SurveyApp] ', message);
    if (dom.errorBanner) {
      dom.errorBanner.textContent = message;
      dom.errorBanner.style.display = 'block';
    }
  }



  /**
   * clearError()
   * 
   * Hides the error banner.
   *
   * Why:
   * Keeps UI clean and feedback minimal unless an error occurs.
   */
  function clearError() {
    if (dom.errorBanner) {
      dom.errorBanner.textContent = '';
      dom.errorBanner.style.display = 'none';
    }
  }



  /**
   * bootstrap()
   * 
   * Entry point: loads survey title, checks availability, and fetches questions if applicable.
   *
   * Why:
   * Decouples survey setup into discrete, recoverable stages.
   */
  function bootstrap() {
    // Load title
    google.script.run.withSuccessHandler(title => {
      dom.formTitle.textContent = title || 'Survey';
    }).withFailureHandler(err => {
      showError('Failed to load survey title. Please refresh.'); 
    }).getTitle(); // Source of title

    // Load status
    google.script.run.withSuccessHandler(statusRaw => {
      surveyStatus = typeof statusRaw === 'string' ? statusRaw.trim() : STATUS_INACTIVE;

      if (surveyStatus !== STATUS_ACTIVE) {
        showUnavailableMessage();
        return;
      }

      // Load question configuration (cfg) only if active status
      google.script.run.withSuccessHandler(cfg => {
        questions = Array.isArray(cfg.questions) ? cfg.questions : [];
        labelOptions = Array.isArray(cfg.labelOptions) ? cfg.labelOptions : [];
        subjectDemographicQuestions = Array.isArray(cfg.subjectDemographicQuestions) ? cfg.subjectDemographicQuestions : [];
        subjectDemographicOptions = Array.isArray(cfg.subjectDemographicOptions) ? cfg.subjectDemographicOptions : [];
        peerDemographicQuestions = Array.isArray(cfg.peerDemographicQuestions) ? cfg.peerDemographicQuestions : [];
        peerDemographicOptions = Array.isArray(cfg.peerDemographicOptions) ? cfg.peerDemographicOptions : [];

        if (!questions.length) {
          showError('No peer review questions configured. Contact the administrator.');
          return;
        }
        
        loadFormContent();
      }).withFailureHandler(err => {
        showError('Failed to load survey configuration. Please try again later.');
      }).getQuestions(); // Source of cfg
    }).withFailureHandler(err => {
        showError('Failed to determine survey availability. Please refresh.');
    }).checkActiveStatus(); // Source of statusRaw
  }



  // --- UI Helper Functions ---
  /**
   * showUnavailableMessage()
   * 
   * Informs the user that the survey is currently unavailable.
   *
   * Why:
   * Ensures clarity when survey window is closed or misconfigured.
   */
  function showUnavailableMessage() {
    dom.submissionMessage.textContent = 'This survey is not currently available';
    dom.submissionMessage.classList.remove('hidden');
    dom.submissionMessage.style.display = 'block';
    hide(dom.loader);
  }



  /**
   * hide(element)
   * 
   * Hides a DOM element by adding a class and setting display.
   * 
   * @param {HTMLElement} element
   */
  function hide(element) {
    if (!element) return;
    element.classList?.add('hidden');
    element.style.display = 'none';
  }



  /**
   * show(element, display = 'block')
   * 
   * Shows a DOM element.
   * The 2nd parameter is a default parameter.
   * 
   * Why:
   * Provides forward-thinking flexibiilty for element display style.
   * 
   * @param {HTMLElement} element
   * @param {string} [display='block']
   */
  function show(element, display = 'block') {
    if (!element) return;
    element.classList?.remove('hidden');
    element.style.display = display;
  }



  /**
   * disableTemporarily(button)
   * 
   * Temporarily disables a button to prevent accidental double-clicks.
   * 
   * @param {HTMLButtonElement} button
   */
  function disableTemporarily(button) {
    if (!button) return;
    button.disabled = true;
    setTimeout(() => { 
      button.disabled = false; 
    }, 50);
  }



  // --- Form Rendering Functions ---
  /**
   * loadFormContent()
   * 
   * Renders the full peer review form based on loaded questions.
   *
   * Why:
   * Dynamically adapts to backend-defined question set and options.
   */
  function loadFormContent() {
    clearError();
    dom.questionsContainer.innerHTML = '';

    questions.forEach((questionTextStr, index) => {
      // Elements created: question container, slider, and two labels
      const questionBlock = document.createElement('div');
      questionBlock.className = 'form-container question-block';

      // TODO: Migrate sizing into CSS instead of inline styles.
      questionBlock.style.width = '90%';
      questionBlock.style.margin = '20px auto';

      const questionText = document.createElement('div');
      questionText.className = 'question';
      questionText.textContent = questionTextStr;

      const labelledSliderContainer = document.createElement('div');
      labelledSliderContainer.className = 'input-container';

      const labels = Array.isArray(labelOptions[index]) && labelOptions[index].length === 2
        ? labelOptions[index] : ['Extreme Negative', 'Extreme Positive'];

      const extremeNegative = document.createElement('label');
      extremeNegative.className = 'extreme-label';
      extremeNegative.textContent = labels[0];

      const extremePositive = document.createElement('label');
      extremePositive.className = 'extreme-label';
      extremePositive.textContent = labels[1];

      const sliderContainer = document.createElement('div');
      sliderContainer.className = 'slider-container';

      const sliderInput = document.createElement('input');
      sliderInput.className = 'slider';
      sliderInput.type = 'range';
      sliderInput.id = `slider_${index}`;
      sliderInput.name = `slider_${index}`;
      sliderInput.min = '0';
      sliderInput.max = '100';
      sliderInput.value = '50';

      sliderContainer.appendChild(sliderInput);

      labelledSliderContainer.appendChild(extremeNegative);
      labelledSliderContainer.appendChild(sliderContainer);
      labelledSliderContainer.appendChild(extremePositive);

      questionBlock.appendChild(questionText);
      questionBlock.appendChild(labelledSliderContainer);
      dom.questionsContainer.appendChild(questionBlock);
    });

    // Prepare peer demographic form
    loadDemographicForm(peerDemographicQuestions, peerDemographicOptions);

    show(dom.submitBlock);
    if (dom.reloadButton) {
      dom.reloadButton.textContent = `REVIEW ANOTHER PEER? (${reviewCount}/${MAX_REVIEWS})`;
      dom.reloadButton.disabled = false;
    }
    hide(dom.loader);
  }



  /**
   * loadDemographicForm(questionSet, optionSet)
   * 
   * Renders demographic questions and their options as radio inputs.
   * 
   * Why:
   * Demographic questions are loaded dynamically to reflect backend configuration.
   * Radios enforce single selection and ensure valid demographic data collection.
   * Hides loader and shows the demographic form to maintain UI responsiveness.
   * 
   * @param {string[]} questionSet - Array of demographic question strings.
   * @param {string[][]} optionSet - Array of option arrays corresponding to each question.
   */
  function loadDemographicForm(questionSet, optionSet) {
    if (!Array.isArray(questionSet) || !Array.isArray(optionSet)) return;

    dom.demographicContainer.innerHTML = '';
    show(dom.demographicForm);
    hide(dom.loader);

    questionSet.forEach((questionTextStr, index) => {
      const questionBlock = document.createElement('div');
      questionBlock.className = 'form-container demographic-question-block';
      questionBlock.style.width = '90%';
      questionBlock.style.margin = '20px auto';

      const questionText = document.createElement('div');
      questionText.className = 'question';
      questionText.textContent = questionTextStr;

      const buttonPanel = document.createElement('div');
      buttonPanel.className = 'button-panel';

      const options = Array.isArray(optionSet[index]) ? optionSet[index] : [];
      options.forEach(option => {
        const radioLabel = document.createElement('label');
        radioLabel.className = 'radio-label';
        radioLabel.textContent = option;

        const radioInput = document.createElement('input');
        radioInput.type = 'radio';
        radioInput.name = `radio_input_${index}`;
        radioInput.value = option;

        radioLabel.appendChild(radioInput);
        buttonPanel.appendChild(radioLabel);
      });

      questionBlock.appendChild(questionText);
      questionBlock.appendChild(buttonPanel);
      dom.demographicContainer.appendChild(questionBlock);
    });
  }



  // --- Validation Functions ---
  /**
   * validateSliderAnswers()
   * 
   * Validates that all peer review slider questions have values.
   *
   * Why:
   * Ensures no question is skipped before submission.
   * Provides immediate user feedback for missing inputs.
   *
   * @returns {string[]|null} Array of slider values if valid, or null if validation fails.
   */
  function validateSliderAnswers() {
    const newResponse = [];

    for (let index = 0; index < questions.length; index++) {
      const slider = document.getElementById(`slider_${index}`);
      if (!slider) {
        showError(`Missing slider for question ${index + 1}.`);
        return null;
      }
      const value = slider.value;
      if (value === undefined || value === null) {
        showError(`Invalid slider value for question ${index + 1}.`);
        return null;
      }
      newResponse.push(value);
    }

    return newResponse;
  }



  /**
   * validateRadioAnswers(questionSet)
   * 
   * Validates that each demographic question has a selected radio answer.
   *
   * Why:
   * Demographic questions must be fully answered to maintain data integrity.
   * Highlights unanswered questions visually to guide user correction.
   * 
   * @param {string[]} questionSet - Array of demographic questions to validate.
   * @returns {string[]|null} Array of selected options if all answered, or null if validation fails.
   */
  function validateRadioAnswers(questionSet) {
    const collected = [];
    let valid = true;
    const questionBlocks = document.getElementsByClassName('demographic-question-block');

    questionSet.forEach((_, index) => {
      const questionBlock = questionBlocks[index];
      const radios = document.getElementsByName(`radio_input_${index}`);
      const selected = Array.from(radios || []).find(r => r.checked);

      if (!selected) {
        if (questionBlock) questionBlock.style.border = '4px solid red';
        valid = false;
      } 
      else {
        if (questionBlock) questionBlock.style.border = '4px solid #E6E63E';
        collected.push(selected.value);
      }
    });

    if (!valid) {
      showError('Please answer all demographic questions before proceeding.');
    }

    return valid ? collected : null;
  }



  // --- Flow Control Functions ---
  /**
   * sendResponse(finalSubmit)
   * 
   * Handles peer review form submission (partial or final).
   *
   * Why:
   * Validates both slider responses and peer demographic answers before proceeding.
   * Aggregates responses to enable multiple peer reviews before final submit.
   * 
   * @param {boolean} finalSubmit - Indicates if this is the final submission.
   */
  function sendResponse(finalSubmit) {
    clearError();
    const newResponse = validateSliderAnswers();
    const newPeerData = validateRadioAnswers(peerDemographicQuestions);

    if (newResponse && newPeerData) {
      responses.push(newResponse);
      peerDemographicData.push(newPeerData);
      proceedToNextPage(finalSubmit);
    } 
    else {
      console.warn('[sendResponse] Validation failed for peer review or peer demographic.');
    }
  }



  /**
   * proceedToNextPage(finalSubmit)
   * 
   * Controls survey navigation flow after a peer review submission.
   *
   * Why:
   * Manages UI state transitions based on survey progress.
   * Smoothly scrolls to top for better user experience.
   * 
   * @param {boolean} finalSubmit - True if user is completing the survey, false to continue peer reviews.
   */
  function proceedToNextPage(finalSubmit) {
    if (!finalSubmit) {
      reviewCount += 1;
      reloadFormContent();
    } 
    else {
      hide(dom.questionsContainer);
      hide(dom.submitBlock);
      show(dom.loader);
      loadDemographicForm(subjectDemographicQuestions, subjectDemographicOptions);
      show(dom.finalSubmitButton);
    }

    document.getElementById('topAnchor').scrollIntoView({ behavior: 'smooth' });
  }



  /**
   * sendSubmission()
   * 
   * Finalizes survey submission by validating subject demographics and sending all collected data.
   *
   * Why:
   * Ensures all required demographic info is complete before submission.
   * Verifies survey availability prior to sending to prevent data loss.
   * Provides user feedback on success or failure.
   */
  function sendSubmission() {
    clearError();
    const newSubjectData = validateRadioAnswers(subjectDemographicQuestions);
    if (!newSubjectData) {
      console.warn('[sendSubmission] Subject demographic validation failed.');
      return;
    }

    subjectDemographicData.splice(0, subjectDemographicData.length, ...newSubjectData);

    hide(dom.demographicForm);
    show(dom.loader);
    hide(dom.finalSubmitButton);

    // Verify availability then submit
    google.script.run.withSuccessHandler(statusRaw => {
      const status = typeof statusRaw === 'string' ? statusRaw.trim() : STATUS_INACTIVE;
      if (status === STATUS_ACTIVE) {
        google.script.run.withSuccessHandler(() => {
          hide(dom.loader);
          dom.submissionMessage.textContent = 'Your response has been recorded';
          show(dom.submissionMessage);
        }).withFailureHandler(err => {
          showError('Submission failed. Please try again.'); 
          hide(dom.loader);
        }).submitResponses(responses, subjectDemographicData, peerDemographicData);
      } 
      else {
        hide(dom.loader);
        dom.submissionMessage.textContent = 'This survey is not currently available';
        show(dom.submissionMessage);
      }
    }).withFailureHandler(err => {
      showError('Could not verify survey status. Please refresh.');
      hide(dom.loader);
    }).checkActiveStatus();
  }



  /**
   * reloadFormContent()
   * 
   * Resets the peer review form for the next peer review iteration.
   *
   * Why:
   * Clears prior responses for fresh input.
   * Prevents user confusion by visually resetting sliders and radio inputs.
   * Disables further peer review if max reviews reached, informing the user.
   */
  function reloadFormContent() {
    // Reset sliders to midpoint.
    questions.forEach((_, index) => {
      const slider = document.getElementById(`slider_${index}`);
      if (slider) slider.value = '50';
    });

    // Reset peer demographic radio selections.
    peerDemographicQuestions.forEach((_, index) => {
      const radios = document.getElementsByName(`radio_input_${index}`);
      Array.from(radios || []).forEach(radio => (radio.checked = false));
    });

    if (dom.reloadButton) {
      dom.reloadButton.textContent = `REVIEW ANOTHER PEER? (${reviewCount}/${MAX_REVIEWS})`;
      if (reviewCount >= MAX_REVIEWS) {
        dom.reloadButton.disabled = true;
        showError(`Maximum of ${MAX_REVIEWS} peer reviews reached.`);
      }
    }
  }

  /**
   * Public API exposed by SurveyApp module.
   *
   * Provides the init function to start the survey application lifecycle.
   *
   * Why:
   * Encapsulates internal state and functions,
   * exposing only what is necessary to minimize global scope pollution.
   * Ensures controlled initialization from outside.
   */
  return {
    init
  };
})();



/**
 * Bootstrap the SurveyApp once the DOM is fully loaded.
 *
 * Why:
 * Ensures that all necessary DOM elements are present before initializing,
 * preventing errors related to missing or unready elements.
 * This event-driven approach aligns with modern best practices for frontend initialization.
 */
document.addEventListener('DOMContentLoaded', () => {
  SurveyApp.init();
});
</script>
